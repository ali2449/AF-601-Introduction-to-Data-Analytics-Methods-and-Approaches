<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functions Module</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
        }
        .section {
            background-color: #2d3748;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }
        pre {
            background-color: #24292e;
            color: #c9d1d9;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        th, td {
            border: 1px solid #4a5568;
            padding: 0.75rem;
            text-align: left;
        }
        th {
            background-color: #2d3748;
        }
        p {
            text-align: justify;
        }
        .relative {
            position: relative;
        }
        .copy-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #4a5568;
            color: #e2e8f0;
            border: none;
            border-radius: 0.5rem;
            padding: 0.25rem 0.75rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .copy-button:hover {
            background-color: #616e7f;
        }
        .copy-button:active {
            background-color: #718096;
        }
    </style>
</head>
<body class="p-6">
    <div class="container">
        <!-- Header -->
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-bold mb-4">Module 4: Python Functions</h1>
            <p class="text-lg text-gray-400">A comprehensive guide to understanding and mastering Python functions.</p>
        </header>

        <!-- Introduction -->
        <section class="section">
            <h2 class="text-3xl font-bold mb-4">Introduction: The Power of Functions</h2>
            <p class="text-gray-300 mb-4">
                Functions represent a cornerstone of effective programming, serving as organized, reusable blocks of code that perform a single, specific task. The fundamental purpose of a function is to encapsulate a piece of logic, allowing a developer to invoke it by a simple, descriptive name rather than rewriting the same code repeatedly. This adherence to the <b>"Don't Repeat Yourself" (DRY) principle</b> is a critical advantage, saving development time and reducing the potential for errors.
            </p>
            <p class="text-gray-300 mb-4">
                Beyond mere repetition, functions are instrumental in enhancing code organization and readability. They allow a complex program to be broken down into smaller, logical, and manageable parts. This makes the codebase easier to understand, maintain, and debug. By giving complex tasks a simple name, such as `process_data()` or `save_report()`, a developer can focus on the high-level flow of the program without getting lost in the minute details of each step. This <b>modular approach</b> is a fundamental shift in programming methodology, enabling the construction of large-scale, scalable systems. In the real world, this modularity is evident across Python's diverse applications, from building robust web frameworks like Django to creating sophisticated data analysis pipelines with libraries like Pandas and NumPy.
            </p>
        </section>

        <!-- Chapter 1 -->
        <section class="section">
            <h2 class="text-3xl font-bold mb-4">Chapter 1: Your First Python Function</h2>
            <h3 class="text-2xl font-bold mt-6 mb-2">The Anatomy of a Function Definition</h3>
            <p class="text-gray-300 mb-4">
                Creating a function in Python begins with the `def` keyword, a mnemonic for "define." This keyword signals the start of a function definition. It is followed by a descriptive function name, a required pair of parentheses, and a colon. The body of the function, which contains the code to be executed, must be indented. For example, a simple function designed to greet a user is structured as follows:
            </p>
            <div class="relative">
                <button class="copy-button">Copy</button>
                <pre><code class="language-python">def greet(name):
    # The code to be executed is indented
    message = f"Hello, {name}!"
    return message</code></pre>
            </div>

            <h3 class="text-2xl font-bold mt-6 mb-2">Calling a Function</h3>
            <p class="text-gray-300 mb-4">
                A function is a named block of code that remains dormant until it is explicitly called. To execute the code within a function, one must call it by its name, followed by parentheses. If the function requires arguments, they are placed inside these parentheses. For instance, to execute the `greet` function from the previous example, one would use the following call:
            </p>
            <div class="relative">
                <button class="copy-button">Copy</button>
                <pre><code class="language-python">greet("Alice")</code></pre>
            </div>

            <h3 class="text-2xl font-bold mt-6 mb-2">The `return` Statement: A Crucial Distinction</h3>
            <p class="text-gray-300 mb-4">
                A key concept for new programmers is the difference between `print()` and `return`. While both can show a result, they serve entirely different purposes.
            </p>
            <p class="text-gray-300 mb-4">
                The `print()` function is a built-in tool that produces a <b>side effect</b>—it displays information to the console. It does not, however, pass data back to the part of the program that called it. A function that only prints is limited in its utility; its output cannot be used in a calculation, assigned to a variable, or passed as input to another function.
            </p>
            <p class="text-gray-300 mb-4">
                In contrast, the `return` statement is a <b>data transfer mechanism</b>. When a function executes a `return` statement, it immediately terminates its execution and sends a value back to the caller. This value can be a number, a string, a list, or any other Python object. The value returned can then be stored in a variable or used in subsequent operations. A function's ability to produce and transfer data is what truly makes it a reusable, modular component of a larger system. By returning a value, a function becomes a <b>data producer</b>, enabling a chain of operations where one function's output becomes another's input, thereby facilitating the creation of complex data pipelines.
            </p>
        </section>

        <!-- Chapter 2 -->
        <section class="section">
            <h2 class="text-3xl font-bold mb-4">Chapter 2: Mastering Arguments and Parameters</h2>
            <h3 class="text-2xl font-bold mt-6 mb-2">Parameters vs. Arguments: The Definitive Guide</h3>
            <p class="text-gray-300 mb-4">
                A common point of confusion for beginners is the difference between <b>parameters</b> and <b>arguments</b>. This distinction is fundamental to understanding how data is passed into a function. Parameters are the placeholders defined in a function's signature. They act as names for the inputs the function expects to receive. Arguments, on the other hand, are the actual values passed to the function when it is called. The relationship is straightforward: when a function is called, the arguments are matched to the parameters to provide the data the function needs to perform its task.
            </p>
            <h3 class="text-2xl font-bold mt-6 mb-2">Types of Arguments</h3>
            <p class="text-gray-300 mb-4">
                Python provides a flexible system for handling arguments, allowing developers to balance simplicity, clarity, and adaptability.
            </p>
            <h4 class="text-xl font-bold mt-4 mb-2">Positional Arguments</h4>
            <p class="text-gray-300 mb-4">
                Positional arguments are the most common type. When a function is called, the arguments are matched to the parameters based on their position, or order. The first argument provided corresponds to the first parameter, the second to the second, and so on. While simple, this method can be prone to errors if the order of arguments is mixed up, which can lead to unexpected and incorrect results.
            </p>
            <div class="relative">
                <button class="copy-button">Copy</button>
                <pre><code class="language-python">def add_numbers(a, b):
    return a + b
result = add_numbers(3, 5) # 3 is for 'a', 5 is for 'b'
print(result) # Output: 8</code></pre>
            </div>

            <h4 class="text-xl font-bold mt-4 mb-2">Keyword Arguments</h4>
            <p class="text-gray-300 mb-4">
                Keyword arguments are passed to a function by explicitly specifying the parameter name followed by an equals sign and the value, for example, `name="Alice"`. This syntax makes the order of the arguments irrelevant, as Python matches the values to the correct parameters by name. This approach is particularly useful for functions with multiple parameters, as it makes the code significantly more readable and less susceptible to ordering-related bugs.
            </p>
            <div class="relative">
                <button class="copy-button">Copy</button>
                <pre><code class="language-python">def greet(name, message):
    print(f"{message}, {name}!") # The order can be swapped without issue
greet(message="Hello", name="Alice") # Output: Hello, Alice!
greet(name="Alice", message="Hello") # Output: Hello, Alice!</code></pre>
            </div>

            <h4 class="text-xl font-bold mt-4 mb-2">Default Arguments</h4>
            <p class="text-gray-300 mb-4">
                A default argument is a parameter that is assigned a predefined value in the function definition. This makes the parameter optional during a function call. If a value is provided, it overrides the default; otherwise, the function uses the default value automatically.
            </p>
            <div class="relative">
                <button class="copy-button">Copy</button>
                <pre><code class="language-python">def greet(name="Guest"):
    print(f"Hello, {name}!")
greet() # Uses the default value, output: Hello, Guest!
greet("Alice") # Overrides the default, output: Hello, Alice!</code></pre>
            </div>
            <p class="text-gray-300 mb-4">
                A significant pitfall for beginners is using a mutable object, like a list or dictionary, as a default value. The default value is created only once, when the function is defined, and is then shared across all future calls. This can cause unwanted side effects where changes from one function call persist in future calls. The correct practice is to use `None` as the default and create the mutable object inside the function.
            </p>

            <h4 class="text-xl font-bold mt-4 mb-2">Variable-Length Arguments (`*args` and `**kwargs`)</h4>
            <p class="text-gray-300 mb-4">
                Python allows functions to accept a variable number of arguments. This is useful when you don't know how many inputs you will have.
            </p>
            <p class="text-gray-300 mb-4">
                The `*args` syntax collects any number of positional arguments into a tuple. The name `args` is a convention, but any name with a single asterisk works.
            </p>
            <div class="relative">
                <button class="copy-button">Copy</button>
                <pre><code class="language-python">def calculate_sum(*numbers):
    total = sum(numbers)
    return total
print(calculate_sum(1, 2, 3)) # Output: 6
print(calculate_sum(1, 2, 3, 4, 5)) # Output: 15</code></pre>
            </div>
            <p class="text-gray-300 mb-4">
                The `**kwargs` syntax collects any number of keyword arguments into a dictionary. The name `kwargs` is a convention, but any name with a double asterisk works.
            </p>
            <div class="relative">
                <button class="copy-button">Copy</button>
                <pre><code class="language-python">def introduce(**details):
    for key, value in details.items():
        print(f"{key}: {value}")
introduce(Name="Alice", Age=25, City="New York")
# Output:
# Name: Alice
# Age: 25
# City: New York</code></pre>
            </div>
            <p class="text-gray-300 mb-4">
                You can use all of these argument types together. When you do, they must appear in a specific order in your function: positional, then default, then `*args`, and finally `**kwargs`.
            </p>
            <h4 class="text-xl font-bold mt-4 mb-2">Argument Summary Table</h4>
            <table>
                <thead>
                    <tr>
                        <th>Argument Type</th>
                        <th>Syntax</th>
                        <th>Key Characteristic</th>
                        <th>When to Use</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Positional</td>
                        <td><code>add(a, b)</code></td>
                        <td>Values are matched by order.</td>
                        <td>Simple functions with few arguments where order is clear.</td>
                    </tr>
                    <tr>
                        <td>Keyword</td>
                        <td><code>add(b=5, a=3)</code></td>
                        <td>Values are matched by parameter name; order is irrelevant.</td>
                        <td>Functions with many parameters or when clarity is needed.</td>
                    </tr>
                    <tr>
                        <td>Default</td>
                        <td><code>greet(name="Guest")</code></td>
                        <td>Provides a predefined value, making the parameter optional.</td>
                        <td>When a function has common or non-essential inputs.</td>
                    </tr>
                    <tr>
                        <td>`*args`</td>
                        <td><code>def my_func(*args)</code></td>
                        <td>Collects an arbitrary number of positional arguments into a tuple.</td>
                        <td>When you don't know how many inputs will be provided.</td>
                    </tr>
                    <tr>
                        <td>`**kwargs`</td>
                        <td><code>def my_func(**kwargs)</code></td>
                        <td>Collects an arbitrary number of keyword arguments into a dictionary.</td>
                        <td>When you need flexible, named inputs.</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Chapter 3 -->
        <section class="section">
            <h2 class="text-3xl font-bold mb-4">Chapter 3: Managing Data with `return`</h2>
            <h3 class="text-2xl font-bold mt-6 mb-2">Returning a Single Value</h3>
            <p class="text-gray-300 mb-4">
                The `return` statement is the main way a function sends a result back. The value that follows the `return` keyword can be any Python object.
            </p>
            <h4 class="text-xl font-bold mt-4 mb-2">The Special Case of `None`</h4>
            <p class="text-3xl font-bold mb-4">
                If a function doesn't have a `return` statement, or if `return` is used without a value, it automatically returns the special value `None`. This is not an error, but an intentional design choice. A function returning `None` means it performed a task, like showing text on the screen or saving to a file, but it didn't produce a value to be used in a later step. It is a clear signal that the function's job was to do something, not to create a result.
            </p>
            <h4 class="text-xl font-bold mt-4 mb-2">Returning Multiple Values</h4>
            <p class="text-gray-300 mb-4">
                Python functions can return multiple values at once by separating them with commas. This works because of something called <b>"tuple packing"</b> and <b>"tuple unpacking."</b> Python always returns a single object. When a function returns comma-separated values, Python puts them into one tuple object. This tuple is then sent back. The caller can then unpack the tuple's contents into separate variables, making it look like multiple values were returned at the same time.
            </p>
            <div class="relative">
                <button class="copy-button">Copy</button>
                <pre><code class="language-python">def get_user_data():
    return 'Anna', 23, 'anna123' # This is a tuple ('Anna', 23, 'anna123')
name, age, id = get_user_data() # Unpacking the tuple
print(f"Name: {name}, Age: {age}, ID: {id}")
# Output: Name: Anna, Age: 23, ID: anna123</code></pre>
            </div>
            <p class="text-gray-300 mb-4">
                This packing and unpacking is a core part of Python. It shows that what looks like a complex return is actually a simple process.
            </p>
        </section>

        <!-- Chapter 4 -->
        <section class="section">
            <h2 class="text-3xl font-bold mb-4">Chapter 4: The World of Variable Scope</h2>
            <h3 class="text-2xl font-bold mt-6 mb-2">Introducing Scope</h3>
            <p class="text-gray-300 mb-4">
                Variable <b>scope</b> is the area of your program where a variable can be seen and used. Understanding scope is vital for avoiding common errors like `NameError` and for writing clean, predictable code. Python follows a rule called <b>LEGB</b> to find a variable: Local, Enclosing, Global, and Built-in.
            </p>
            <ul class="list-disc pl-5 space-y-2 text-gray-300">
                <li><strong>Local Scope:</strong> This is the innermost scope. Variables created inside a function are local to that function. They can only be used from within that function. They are created when the function is called and disappear when it finishes.</li>
                <li><strong>Enclosing Scope:</strong> This scope is for nested functions. A variable in an outer function can be used by an inner function.</li>
                <li><strong>Global Scope:</strong> This is the top-level scope of a script. Variables created outside of any function are global and can be used anywhere in the program.</li>
                <li><strong>Built-in Scope:</strong> This is the widest scope. It holds all of Python's pre-defined names, like `print()` and `len()`. These names are always available.</li>
            </ul>

            <h3 class="text-2xl font-bold mt-6 mb-2">The `global` Keyword</h3>
            <p class="text-gray-300 mb-4">
                By default, if you set a variable inside a function, Python creates a new local variable, even if a global variable with the same name exists. This is called <b>"shadowing."</b> It's a safety feature that stops a function from accidentally changing a global variable. This prevents bugs that are hard to find.
            </p>
            <p class="text-gray-300 mb-4">
                To intentionally change a global variable from inside a function, you must use the <b>`global` keyword</b>. When you declare `global variable_name` inside a function, you tell Python to change the variable in the global scope instead of making a new local one.
            </p>
            <div class="relative">
                <button class="copy-button">Copy</button>
                <pre><code class="language-python">x = 10 # Global variable
def modify_x():
    x = 5 # Creates a new local variable, x
    print(f"Inside: x is now {x}")
modify_x()
print(f"Outside: x is still {x}")
# Output:
# Inside: x is now 5
# Outside: x is still 10

def modify_global_x():
    global x # Declares intent to modify the global variable
    x = 5 # Modifies the global x
    print(f"Inside: x is now {x}")
modify_global_x()
print(f"Outside: x is now {x}")
# Output:
# Inside: x is now 5
# Outside: x is now 5</code></pre>
            </div>
            <p class="text-gray-300 mb-4">
                Using the `global` keyword is a choice you make on purpose. It overrides Python's default safety, so you should use it with care. Changing a shared variable from different parts of a program can create complex dependencies and make debugging much harder.
            </p>
            <h4 class="text-xl font-bold mt-4 mb-2">Variable Scope Comparison</h4>
            <table>
                <thead>
                    <tr>
                        <th>Characteristic</th>
                        <th>Local Variable</th>
                        <th>Global Variable</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Definition Location</td>
                        <td>Inside a function</td>
                        <td>Outside of all functions</td>
                    </tr>
                    <tr>
                        <td>Scope</td>
                        <td>Accessible only within the function</td>
                        <td>Accessible throughout the entire program</td>
                    </tr>
                    <tr>
                        <td>Lifetime</td>
                        <td>Exists only during the function's execution</td>
                        <td>Remains in memory for the duration of the program</td>
                    </tr>
                    <tr>
                        <td>Access</td>
                        <td>Cannot be accessed outside its function</td>
                        <td>Can be accessed by any function in the program</td>
                    </tr>
                    <tr>
                        <td>Modification Keyword</td>
                        <td>No special keyword required</td>
                        <td>`global` keyword required to modify inside a function</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Chapter 5 -->
        <section class="section">
            <h2 class="text-3xl font-bold mb-4">Chapter 5: Exploring Advanced Functional Concepts</h2>
            <h3 class="text-2xl font-bold mt-6 mb-2">Lambda Functions: The One-Liner for Simple Tasks</h3>
            <p class="text-gray-300 mb-4">
                A <b>lambda function</b> is a small, anonymous function. You create it with the `lambda` keyword. It's "anonymous" because it has no name, though you can save it to a variable. The syntax is short: `lambda arguments: expression`. The function body is a single line of code, and its result is returned automatically, without needing a `return` statement.
            </p>
            <p class="text-gray-300 mb-4">
                Lambda functions are not a replacement for regular functions. They are a lightweight tool for when you need a simple function that won't be used again. They are often used as inputs for <b>higher-order functions</b>—functions that take other functions as arguments. Examples include:
            </p>
            <ul class="list-disc pl-5 space-y-2 text-gray-300">
                <li>`map()`: Applies a function to every item in a list or other iterable. It creates a new iterable with the results.</li>
                <li>`filter()`: Creates a new iterable from items that meet a certain condition.</li>
                <li>`sorted()`: Sorts a list based on a custom rule.</li>
            </ul>
            <div class="relative">
                <button class="copy-button">Copy</button>
                <pre><code class="language-python">numbers = [1, 2, 3, 4, 5, 6]
# Use lambda with map() to double each number
doubled_numbers = list(map(lambda x: x * 2, numbers))
print(doubled_numbers) # Output: [2, 4, 6, 8, 10, 12]

# Use lambda with filter() to get only even numbers
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens) # Output: [2, 4, 6]</code></pre>
            </div>

            <h3 class="text-2xl font-bold mt-6 mb-2">Recursive Functions</h3>
            <p class="text-gray-300 mb-4">
                A <b>recursive function</b> is one that calls itself to solve a problem. This is often used for problems that can be broken down into smaller, similar sub-problems, like calculating a factorial.
            </p>
            <p class="text-gray-300 mb-4">
                Every recursive function needs a <b>base case</b>. The base case is a condition that tells the function when to stop calling itself. This prevents an endless loop. Without a base case, the function will keep calling itself forever, which will lead to a `RecursionError`.
            </p>
            <div class="relative">
                <button class="copy-button">Copy</button>
                <pre><code class="language-python">def factorial(n):
    # Base case: if n is 1, stop the recursion and return 1
    if n == 1:
        return 1
    else:
        # Recursive case: call the function with a smaller number
        return n * factorial(n - 1)
print(factorial(5)) # Output: 120
# 5 * factorial(4) -> 5 * (4 * factorial(3)) ->...</code></pre>
            </div>
        </section>

        <!-- Chapter 6 -->
        <section class="section">
            <h2 class="text-3xl font-bold mb-4">Chapter 6: Practical Applications and Real-World Examples</h2>
            <p class="text-gray-300 mb-4">
                The real power of functions shows up when you use them to solve real problems. They are the basic parts for building complex apps in many different areas.
            </p>
            <h4 class="text-xl font-bold mt-4 mb-2">Data Processing and Analysis:</h4>
            <p class="text-gray-300 mb-4">
                In data science, functions are used for tasks that repeat. For example, you can write a function to clean raw data, and then reuse it on many different datasets. Python tools like Pandas and NumPy are built on this idea. They let data experts create reusable pipelines that can automatically collect, clean, and analyze data.
            </p>
            <h4 class="text-xl font-bold mt-4 mb-2">Web Development and Automation:</h4>
            <p class="text-gray-300 mb-4">
                Functions are the core logic in web frameworks like Django and Flask. There, each web address can be linked to a specific function. In automation, you can create a function to handle a repeated task, like reading from a spreadsheet and sending an email. This way of building code creates strong, easy-to-manage systems that you can change and add to.
            </p>
            <p class="text-gray-300 mb-4">
                A good example of this is a score-averaging system. By breaking the task into smaller functions like `promptAndProcess()` and `processScores()`, the program becomes a series of logical steps instead of one large block of code. This <b>separation of concerns</b> makes debugging easier and makes the program simpler to read and maintain.
            </p>
        </section>

        <!-- Chapter 7 -->
        <section class="section">
            <h2 class="text-3xl font-bold mb-4">Chapter 7: Writing Clean, Professional Python</h2>
            <h3 class="text-2xl font-bold mt-6 mb-2">Best Practices for Function Design</h3>
            <p class="text-gray-300 mb-4">
                To write good, professional Python code, you should follow a few key rules.
            </p>
            <h4 class="text-xl font-bold mt-4 mb-2">The Single Responsibility Principle:</h4>
            <p class="text-gray-300 mb-4">
                A function should do "one thing and do it well." A function that tries to do too many things is a sign that you should split it up. Breaking it into smaller, focused functions, like `calculate_metrics()` and `write_report()`, makes the code easier to understand, test, and manage.
            </p>
            <h4 class="text-xl font-bold mt-4 mb-2">Documentation and Clarity:</h4>
            <p class="text-gray-300 mb-4">
                It's very important to document your functions. <b>Docstrings</b> are multi-line strings at the start of a function that explain what it does, its parameters, and what it returns. This documentation is a huge help to other developers (and your future self). Also, using clear names for functions and parameters is a simple but powerful way to improve code readability.
            </p>
            <h4 class="text-xl font-bold mt-4 mb-2">Type Hints:</h4>
            <p class="text-gray-300 mb-4">
                Python is a dynamically typed language, but adding <b>type hints</b> (e.g., `def add(a: int, b: int) -> int:`) shows the expected data types. These hints don't change how the code runs, but they serve as great documentation and can help tools catch type-related errors before you even run the code.
            </p>
            <h3 class="text-2xl font-bold mt-6 mb-2">Common Pitfalls and How to Avoid Them</h3>
            <p class="text-gray-300 mb-4">
                Even experienced developers can make mistakes. Knowing how to spot and prevent common errors is a key part of learning.
            </p>
            <ul class="list-disc pl-5 space-y-2 text-gray-300">
                <li><strong>Forgetting Parentheses:</strong> Beginners often forget the parentheses when calling a function. Without the parentheses, Python sees the function as an object, not as a command to run the code. This will not cause an error but will lead to unexpected behavior, as the program will try to use the function object itself.</li>
                <li><strong>Missing Colons and Indentation:</strong> Python uses colons to start a new code block and indentation to define its scope. Forgetting a colon at the end of a function definition or using inconsistent indentation will result in a `SyntaxError` or `IndentationError`.</li>
                <li><strong>Mixing Positional and Keyword Arguments:</strong> When a function uses both positional and keyword arguments, positional arguments must always come first in the function call. If you don't follow this rule, you will get a `SyntaxError`.</li>
                <li><strong>Scope Misunderstanding:</strong> If you try to change a global variable inside a function without using the `global` keyword, you will get an `UnboundLocalError`. This happens because Python assumes you want to create a new local variable, but you haven't given it a value yet. To avoid this, either use the `global` keyword or pass the variable as an argument and return the changed value.</li>
            </ul>
            <h4 class="text-xl font-bold mt-4 mb-2">Common Error Table</h4>
            <table>
                <thead>
                    <tr>
                        <th>Error Type</th>
                        <th>Cause</th>
                        <th>Example</th>
                        <th>Solution</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>`SyntaxError`</td>
                        <td>Missing a colon or parentheses.</td>
                        <td>`def my_func()`</td>
                        <td>`def my_func():`</td>
                    </tr>
                    <tr>
                        <td>`TypeError`</td>
                        <td>Passing an incorrect data type or the wrong number of arguments.</td>
                        <td>`print("Hello" + 5)`</td>
                        <td>`print("Hello" + str(5))`</td>
                    </tr>
                    <tr>
                        <td>`NameError`</td>
                        <td>Referencing a variable or function that has not been defined.</td>
                        <td>`print(my_variable)`</td>
                        <td>Define `my_variable` before using it.</td>
                    </tr>
                    <tr>
                        <td>`IndentationError`</td>
                        <td>Inconsistent or incorrect use of whitespace.</td>
                        <td>`def my_func(): print("Hello")` (un-indented)</td>
                        <td>`def my_func():<br> &nbsp;&nbsp;&nbsp;&nbsp;print("Hello")`</td>
                    </tr>
                    <tr>
                        <td>`UnboundLocalError`</td>
                        <td>Attempting to modify a global variable without using the `global` keyword.</td>
                        <td>`x = 5`<br>`def my_func():`<br>&nbsp;&nbsp;&nbsp;&nbsp;`x += 1`</td>
                        <td>`global x`<br>`x = 5`</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Conclusion -->
        <section class="section">
            <h2 class="text-3xl font-bold mb-4">Conclusion</h2>
            <p class="text-gray-300 mb-4">
                The journey from a beginner to an expert in Python functions is a progression from simple syntax to nuanced design principles. Functions are more than just a way to avoid writing the same code twice. They are a powerful tool for structuring and managing complex programs. By understanding the core mechanics—like the difference between `print` and `return`, the types of arguments, and the rules of variable scope—you can turn your simple code into a professional application. Mastering these ideas is key to moving on to more advanced topics. It is the path to becoming a truly skilled programmer.
            </p>
        </section>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const codeBlocks = document.querySelectorAll('.relative');

            codeBlocks.forEach(block => {
                const copyButton = block.querySelector('.copy-button');
                const codeElement = block.querySelector('code');

                copyButton.addEventListener('click', () => {
                    const textToCopy = codeElement.innerText;

                    // Use document.execCommand('copy') for better cross-browser support in a sandbox environment
                    const tempTextArea = document.createElement('textarea');
                    tempTextArea.value = textToCopy;
                    document.body.appendChild(tempTextArea);
                    tempTextArea.select();
                    tempTextArea.setSelectionRange(0, 99999); // For mobile devices

                    try {
                        document.execCommand('copy');
                        copyButton.innerText = 'Copied!';
                        setTimeout(() => {
                            copyButton.innerText = 'Copy';
                        }, 2000);
                    } catch (err) {
                        console.error('Failed to copy text: ', err);
                    } finally {
                        document.body.removeChild(tempTextArea);
                    }
                });
            });
        });
    </script>
</body>
</html>
